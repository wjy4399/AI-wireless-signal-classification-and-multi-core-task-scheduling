# affinity-task-scheduling-system
使用贪心算法优化我的代码，使其在满足约束条件下获得更高分数。约束条件为：“
在基站系统中，共有 M 台机器和 N 项任务待处理，任务定义为= <MsgType, 
UsrInst, ExeTime, DeadLine>，携带以下几项信息：
MsgType：基站处理的任务类型，范围 0 ≤ 𝑀𝑠𝑔𝑇𝑦𝑝𝑒 ≤ 200
⚫ UsrInst：基站接入的用户实例号，范围 0 ≤ 𝑈𝑠𝑟𝐼𝑛𝑠𝑡 ≤ 10000
⚫ ExeTime：处理本任务耗时，简化为整数，其范围 1 ≤ ExeTime≤ 4000；
⚫ DeadLine：任务进入系统即开始计时，在此之前需要处理完，其范围 1 ≤
 DeadLine ≤ 4294967295;
⚫ 保证<MsgType, UsrInst>唯一，即每条任务都是独一无二的
你需要将 N 个待处理的任务，依照时间顺序分配到 M 个机器上。分配的约束要求包
括：
⚫ 同一用户实例的任务顺序不能乱序，只有当某任务的前序任务均完成时，该任务
才可以启动
⚫ 一个机器同时只能处理一个任务
⚫ 当一个任务启动时，必须执行完毕
⚫ 不同核的执行时序无法保证，核内的执行时序能保证为:先进先出，即同一个用户
的任务不能分配到不同的核上，因为无法保证执行时序
⚫ 必须完成所有任务的分配
核在执行任务处理任务时，如果任务类型不断变更，则核需要不断切换加载不同指
令，导致 CacheMiss 提高。”分数公式为：“优化目标
➢ 亲和性评价(AffinityScore)：影响处理效率。当一个 Core 连续处理两条相同类型
的任务时亲和性较好，亲和得分+1，如出现连续处理多条相同类型任务时，分别
计算每两个相邻任务的亲和得分并累加。
➢ 处理能力评价(CapabilityScore)：处理能力，给定系统最大处理时长 C 以及每个任
务的最晚结束时间，处理不超时的任务总数即为处理能力得分。
基于以上评价维度，选手单个用例的得分评价公式定义为：
选手得分$= \textit{亲 和 性 得 分 }+ \textit{未 超 时 的 任 务 数 }$

为了平衡各个用例集规模导致的得分差异，需要进行归一化处理。针对此评分公式，
我们可以得出一个绝对上界：

### 绝对上界$= \textit{任务数 N}+ \textit{任务数 N}$

基于此进行得分的归一化和规格扩充，选手单用例的最终得分评价为：

单个用例调度得分$=100000*log10(N)*\left(1+\frac{\textit{选手得分}-\textit{绝对上界}}{\textit{绝对上界}}\right)$”
